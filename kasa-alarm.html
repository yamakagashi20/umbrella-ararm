<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>傘忘れ防止リマインダー (改)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans JP', 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        button:active {
            transform: scale(0.98);
        }
        input[type="time"] {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div id="app-container" class="container mx-auto p-4 sm:p-6 max-w-lg bg-white rounded-xl shadow-2xl">
        <header class="text-center mb-6 sm:mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-blue-600">傘忘れ防止リマインダー</h1>
            <p class="text-gray-500 mt-1">大切な傘を忘れないために (画面オフ対応版)</p>
        </header>

        <div id="notification-permission-area" class="mb-4 p-3 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 hidden">
            <p>画面を閉じていても通知を受け取るには、通知の許可が必要です。</p>
            <button id="request-notification-btn" class="mt-2 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-3 rounded text-sm">
                通知を許可する
            </button>
        </div>

        <div id="status-area" class="mb-6 sm:mb-8 p-4 sm:p-5 bg-blue-50 rounded-lg shadow">
            <p id="status-text" class="text-lg sm:text-xl text-blue-700 font-semibold">リマインダーはセットされていません。</p>
            <p id="reminder-time-text" class="text-sm sm:text-base text-gray-600 mt-1"></p>
        </div>

        <div id="controls-area" class="space-y-4 sm:space-y-5">
            <div class="flex flex-col items-start space-y-2">
                <label for="return-time" class="text-lg text-gray-700 font-medium">帰宅予定時刻：</label>
                <input type="time" id="return-time" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-150 text-lg">
            </div>
            <button id="set-reminder-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg transition duration-150 text-lg shadow-md hover:shadow-lg">
                リマインダーをセット
            </button>
            <button id="cancel-reminder-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg transition duration-150 text-lg shadow-md hover:shadow-lg hidden">
                リマインダーを解除
            </button>
        </div>

        <div id="alarm-modal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 hidden z-50 transition-opacity duration-300 opacity-0">
            <div class="bg-white p-6 sm:p-8 rounded-xl shadow-xl text-center max-w-md w-full transform scale-95 transition-transform duration-300">
                <h2 class="text-3xl sm:text-4xl font-bold text-red-600 mb-3">アラーム！</h2>
                <div class="text-6xl sm:text-7xl my-4 sm:my-6" role="img" aria-label="傘のアイコン">☂️</div>
                <p id="alarm-text" class="text-lg sm:text-xl text-gray-800 mb-6 sm:mb-8">傘を忘れていませんか？<br>玄関先などを確認してください！</p>
                <button id="dismiss-alarm-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 sm:py-4 px-4 rounded-lg transition duration-150 text-lg shadow-md hover:shadow-lg">
                    確認しました (ページ内アラーム)
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const statusText = document.getElementById('status-text');
            const reminderTimeText = document.getElementById('reminder-time-text');
            const returnTimeInput = document.getElementById('return-time');
            const setReminderBtn = document.getElementById('set-reminder-btn');
            const cancelReminderBtn = document.getElementById('cancel-reminder-btn');
            const alarmModal = document.getElementById('alarm-modal');
            const dismissAlarmBtn = document.getElementById('dismiss-alarm-btn');
            const notificationPermissionArea = document.getElementById('notification-permission-area');
            const requestNotificationBtn = document.getElementById('request-notification-btn');

            const localStorageKey = 'umbrellaReminder';
            let reminderData = {
                isActive: false,
                alarmTime: null,
                returnTimeInput: null
            };

            let synth;
            let alarmSoundLoop;
            let alarmCheckIntervalId = null;

            // --- Service Worker and Notifications ---
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                        // Check for active worker and messages can be sent.
                        // Useful if the page is reloaded and SW is already active.
                        if (registration.active) {
                            console.log('Service Worker is active.');
                        }
                    })
                    .catch(error => console.error('Service Worker registration failed:', error));
            }

            function checkNotificationPermission(showRequestUI = false) {
                if (!('Notification' in window)) {
                    console.warn('This browser does not support desktop notification');
                    return false;
                }
                if (Notification.permission === 'granted') {
                    notificationPermissionArea.classList.add('hidden');
                    return true;
                }
                if (Notification.permission === 'denied') {
                    notificationPermissionArea.classList.remove('hidden');
                    notificationPermissionArea.querySelector('p').textContent = '通知はブロックされています。ブラウザの設定で許可してください。';
                    requestNotificationBtn.classList.add('hidden');
                    return false;
                }
                if (showRequestUI) {
                    notificationPermissionArea.classList.remove('hidden');
                }
                return false;
            }

            requestNotificationBtn.addEventListener('click', () => {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('Notification permission granted.');
                        notificationPermissionArea.classList.add('hidden');
                    } else {
                        console.log('Notification permission denied.');
                        notificationPermissionArea.querySelector('p').textContent = '通知の許可がありませんでした。';
                    }
                    checkNotificationPermission(); // Update UI based on new permission
                });
            });
            // --- End Service Worker and Notifications ---


            function initializeAudio() {
                if (!synth && window.Tone) {
                    synth = new Tone.Synth().toDestination();
                }
            }
            
            async function ensureAudioContextResumed() {
                if (window.Tone && Tone.context.state === 'suspended') {
                    try {
                        await Tone.start();
                    } catch (e) { console.error("Failed to resume AudioContext:", e); }
                }
                initializeAudio();
            }

            function updateUI() {
                if (reminderData.isActive && reminderData.alarmTime) {
                    statusText.textContent = 'リマインダー作動中';
                    statusText.classList.replace('text-blue-700', 'text-green-700');
                    const alarmDate = new Date(reminderData.alarmTime);
                    reminderTimeText.textContent = `通知予定: ${alarmDate.toLocaleDateString('ja-JP')} ${alarmDate.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', hour12: false })}`;
                    setReminderBtn.textContent = 'リマインダーを更新';
                    cancelReminderBtn.classList.remove('hidden');
                    if (reminderData.returnTimeInput) {
                        returnTimeInput.value = reminderData.returnTimeInput;
                    }
                } else {
                    statusText.textContent = 'リマインダーはセットされていません。';
                    statusText.classList.replace('text-green-700', 'text-blue-700');
                    reminderTimeText.textContent = '';
                    setReminderBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /></svg> リマインダーをセット`;
                    cancelReminderBtn.classList.add('hidden');
                }
            }

            function saveReminder() {
                localStorage.setItem(localStorageKey, JSON.stringify(reminderData));
            }

            function loadReminder() {
                const storedData = localStorage.getItem(localStorageKey);
                if (storedData) {
                    reminderData = JSON.parse(storedData);
                }
                updateUI();
            }

            async function postMessageToServiceWorker(message) {
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage(message);
                    return true;
                } else if ('serviceWorker' in navigator) {
                    // If controller is not yet available, wait for it.
                    try {
                        const registration = await navigator.serviceWorker.ready;
                        if (registration.active) {
                            registration.active.postMessage(message);
                            return true;
                        } else {
                            console.warn('Service Worker active but no controller to post message immediately.');
                            return false;
                        }
                    } catch (err) {
                        console.error('Error getting SW ready to post message:', err);
                        return false;
                    }
                }
                return false;
            }


            async function handleSetReminder() {
                await ensureAudioContextResumed();

                if (Notification.permission !== 'granted') {
                    checkNotificationPermission(true); // Show UI to request permission
                    // Optionally alert or guide user if permission is crucial
                    // alert('バックグラウンド通知には許可が必要です。ページ上部の指示に従ってください。');
                    // return; // Or allow setting in-page alarm only
                }


                const timeValue = returnTimeInput.value;
                if (!timeValue) {
                    alert('帰宅予定時刻を入力してください。');
                    return;
                }

                const [hours, minutes] = timeValue.split(':').map(Number);
                const now = new Date();
                let alarmDateTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0, 0);

                if (alarmDateTime <= now) {
                    alarmDateTime.setDate(alarmDateTime.getDate() + 1);
                }

                reminderData.isActive = true;
                reminderData.alarmTime = alarmDateTime.toISOString();
                reminderData.returnTimeInput = timeValue;

                saveReminder();
                updateUI();
                
                // Schedule background notification via Service Worker
                const swScheduled = await postMessageToServiceWorker({
                    type: 'SCHEDULE_ALARM',
                    alarmTime: reminderData.alarmTime
                });
                if(swScheduled) console.log('Background alarm instruction sent to Service Worker.');
                else if (Notification.permission === 'granted') console.warn('Could not send alarm to Service Worker immediately.');


                // Start in-page alarm check (as fallback or for when page is active)
                startAlarmCheckInterval();
                console.log(`Reminder set for: ${reminderData.alarmTime}`);
            }

            async function handleCancelReminder() {
                reminderData.isActive = false;
                reminderData.alarmTime = null;
                reminderData.returnTimeInput = null;

                saveReminder();
                updateUI();
                stopAlarmCheckInterval();
                stopAlarmSound();
                hideAlarmModal();

                // Cancel background notification via Service Worker
                await postMessageToServiceWorker({ type: 'CANCEL_ALARM' });
                console.log("Reminder cancelled. Cancellation instruction sent to Service Worker.");
            }

            function checkAlarmLogic() {
                if (reminderData.isActive && reminderData.alarmTime) {
                    const now = new Date();
                    const alarmTime = new Date(reminderData.alarmTime);
                    if (now >= alarmTime) {
                        triggerInPageAlarm(); // In-page alarm
                    }
                } else {
                    stopAlarmCheckInterval();
                }
            }

            function startAlarmCheckInterval() {
                stopAlarmCheckInterval(); 
                if (reminderData.isActive && reminderData.alarmTime) {
                    checkAlarmLogic(); 
                    alarmCheckIntervalId = setInterval(checkAlarmLogic, 5000);
                }
            }

            function stopAlarmCheckInterval() {
                if (alarmCheckIntervalId) {
                    clearInterval(alarmCheckIntervalId);
                    alarmCheckIntervalId = null;
                }
            }
            
            async function triggerInPageAlarm() { // Renamed to avoid confusion
                if (alarmModal.classList.contains('hidden')) {
                    await ensureAudioContextResumed();
                    alarmModal.classList.remove('hidden');
                    setTimeout(() => {
                        alarmModal.classList.remove('opacity-0');
                        alarmModal.querySelector('div').classList.remove('scale-95');
                    }, 10);
                    playAlarmSound();
                }
            }

            function hideAlarmModal() {
                alarmModal.classList.add('opacity-0');
                alarmModal.querySelector('div').classList.add('scale-95');
                setTimeout(() => alarmModal.classList.add('hidden'), 300);
            }

            async function dismissAlarm() { // This dismisses the in-page alarm
                hideAlarmModal();
                stopAlarmSound();
                // This effectively cancels the reminder, including background task
                await handleCancelReminder(); 
                console.log("In-page alarm dismissed.");
            }

            function playAlarmSound() {
                if (!synth) return;
                if (Tone.Transport.state !== "started") Tone.Transport.start();
                if (!alarmSoundLoop) {
                    alarmSoundLoop = new Tone.Loop(time => synth.triggerAttackRelease("C5", "8n", time), "1s").start(0);
                }
            }

            function stopAlarmSound() {
                if (alarmSoundLoop) {
                    alarmSoundLoop.stop(0);
                    alarmSoundLoop.dispose();
                    alarmSoundLoop = null;
                }
            }

            setReminderBtn.addEventListener('click', handleSetReminder);
            cancelReminderBtn.addEventListener('click', handleCancelReminder);
            dismissAlarmBtn.addEventListener('click', dismissAlarm);

            loadReminder();
            ensureAudioContextResumed().then(() => {
                if (reminderData.isActive && reminderData.alarmTime) {
                    startAlarmCheckInterval();
                }
            });
            
            const now = new Date();
            now.setHours(now.getHours() + 1);
            if (!returnTimeInput.value) {
                 returnTimeInput.value = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            }
            // Initial check for notification permission and show UI if needed
            // We delay showing the request UI slightly to not be too intrusive on load.
            setTimeout(() => checkNotificationPermission(true), 1000);
        });
    </script>
</body>
</html>
